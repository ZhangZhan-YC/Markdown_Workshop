# 第一章 数据库系统概述
## 1.4 数据库系统
  数据库系统
   - 支持数据共享
   - 控制数据冗余
   - 数据完整一致
   - 数据独立性搞
   - 支持复杂结构
   - 三种数据抽象
   - 正确安全可靠
## 1.5 数据抽象与数据模型
  数据抽象：隐藏数据存储和维护的细节，简化用户与系统的交互
   - 视图抽象
   - 逻辑抽象
   - 物理抽象
  
  数据独立性：
   - 物理数据独立性
     - 由物理模式/逻辑模式映射实现
     - 物理模式改变时，只改变物理模式/逻辑模式映射
   - 逻辑数据独立性
     - 由逻辑模式/视图模式映射实现
     - 当逻辑模式改变时，只改变逻辑模式/视图模式映射
  
  数据模型的基本要素：
   - 数据结构
   - 数据操作
   - 数据的完整性约束
  
  常用的数据模型：
   - 实体关系（E-R）数据模型
   - 面向对象（O-O）数据模型
   - 关系数据模型
   - 对象关系（O-R）数据模型
   - 层次和网络数据模型

  层次数据模型：（树状）
   - 满足下面两个条件的基本层次联系的集合为层次模型：
     - 有且只有一个节点没有父节点，称为根节点
     - 根以外的其他节点有且只有一个父亲节点
   - 层次模型的数据结构是满足下列条件的树：
     - 每个节点：一个现实世界的对象的数据记录（实体）
     - 边表示对象之间的联系
   - 特点：
     - 父亲唯一，所以只能直接处理一对多的实体联系
     - 任何记录值只有按其路径查看时，才能显示出它的全部意义
     - 没有子女记录值脱离父亲记录纸而独立存在。
   - 完整性约束：
     - 无相应的父亲节点就不能插入子女节点值
     - 如果删除父亲节点值，则相应的子女节点值也会被同时删除
     - 更新数据时，应更新所有相应的记录，以保证数据的一致性
   - 优点：
     - 简单
     - 良好的完整性支持
   - 缺点：
     - 多堆垛联系表示不自然
     - 对插入和删除操作的限制多
     - 查询子女节点必须通过父亲节点
     - 面向过程 
  
  网状数据模型：
   - 网状模型的数据结构是满足下列条件的图：
     - 每个节点是一个对象记录
     - 边表示对象之间的联系
     - 允许多个节点无父亲节点
     - 允许节点有多个父亲节点
     - 允许两个节点之间有多重联系
   - 完整性约束条件不严格
     - 允许插入尚未确定父亲节点值的子女节点值
     - 允许只删除父亲节点值
     - 一些具体联系提供了一些完整性约束
   - 优点：
     - 能够更为直接的描述现实世界
     - 具有良好的性能，查询更新等不需要访问父亲节点
   - 缺点：
     - 结构复杂，不利于最终用户掌握
     - 语言复杂，不易使用
     - 面向过程
# 关系数据库系统
## 2.1 简介
## 2.2 关系模型
### 2.2.1 数据结构
  关系模型建立在集合代数的基础上。

  单一的数据结构--关系

  数据的逻辑结构--二维表

  关系数据库由表构成，每个表有唯一的名字，称之为关系。
   - 元组：用来指代关系表的行。顺序无关紧要。
   - 属性：用来指代关系表的列。顺序无关紧要。n元关系有n个属性。
   - 域：每个允许取值的关系的属性的所有可能属性值得集合。
   - 数学解释：$设A_1、A_2、...、A_n是值域为D_1、D_2、...、D_n的n个属性。具有属性A_1、A_2、...、A_n的关系R是一个元组结合，其中，每个元组是一个映射集合\{\{A_1\}\rightarrow D_1,\{A_2\}\rightarrow D_2,...,\{A_n\}\rightarrow D_n\}$
   - 性质：
     - 列是同质的（同一类型的数据，来自同一个域）
     - 不同的列可以出资同一个域
     - 列的顺序无所谓
     - 任意两个元组不能完全相同 
     - 行的顺序无所谓
     - 分量必须取原子值（不可再分）
  
  关系模式：具有形式$R(U,D,DOM,I,F)，简记为R(U)$其中：
   - R是关系名
   - U是R的属性集合$\{A_1,A_2,...,A_n\}$
   - D是U中属性的域集合$\{D_1,D_2,...,D_n\}$
   - DOM是U到D的映射
   - I是完整性约束集合
   - F是属性间的函数依赖关系
  
  关系数据库模式：一组关系模式的集合
### 2.2.2 完整性约束
  超码：一个或多个属性的集合，这些属性的组合可以在一个关系中唯一地标识一个元组
   - 超码中可能包含无关紧要的属性。
  
  候选码：
   - 满足下列关系时K称为关系R(U)的一个候选码：
     - K是R(U)的一个超码
     - K的仁义镇自己都不能称为R(U)的超码
   - 即最小的超码
   - 一个关系模式可以有多个候选码
  
  主码：
   - 被数据库设计者选中的，用来在一个关系中区分不同元组的候选码
   - 主码中的属性称为主属性
   - 一个关系模式只能有一个主码
  
  外码：
   - 关系模式r1的属性包括另一个关系模式r2的主码，则这个属性集合在r1上称作参照r2的外码
   - 并不一定要与相应的主码同名，往往取相同的名字
  
  关系数据模型的完整性约束：
   - 实体完整性约束：
    - 如果A是关系模式R(U)的主属性，则A不能取空值
    - 保证主属性不空与关系模式用主码唯一标识元组是统一的
   - 参照完整性约束：
     - 定义了主码与外码之间的规则
     - 要求在参照关系中，任意元组在特定属性上的取值必然等于被参照关系中某个元祖在特定属性上的取值。
   - 其他类型的约束：
     - 语义完整性约束
     - 函数依赖
## 2.3 关系运算
### 2.3.1 关系代数（过程性的）
  是一个过程化查询语言。多个关系运算组合成一个关系代数表达式。

  六种基本运算：
  - 选择（选行）$\sigma$
     - $\sigma_P(R) = \{t|t\in R and P(t)\}$
     - P为选择谓词：交并非的子表达式的组合的公式
   - 投影（选列）$\Pi$
     - $\Pi_{A_1,A_2,...,A_n}(R)$
     - 选择属性名。删去重复元组。 
   - 差$-$
     - $R-S = \{t|t\in R and t\notin S\}$
     - 做并运算的关系是相容的。
       - 关系R和S满足：1、属性个数相同。2、第i个属性的域相同。
     - 无重复元组。
   - 并$\bigcup$
     - $R\bigcup S = \{r|r\in R or t\in S\}$
     - 必须保证做并运算的关系是相容的。
     - 前后顺序不同结果不同。 
     - 无重复元组
   - 笛卡尔积$\times$
     - $R\times S = \{tq|t\in R and Q\in S\}$
     - 将任意两个关系的信息组合在一起。
     - R和S的属性是不相交的。若相交，则重命名。
   - 重命名 $\rho$
     - $\rho_{S(A_1,A_2,...)}(R)$
     - 将关系重命名，S的属性从左到右为$A_1,A_2,...$。
     - 只修改关系命则不带属性。 
  
  其他关系代数运算：（不增加表达能力，但简化表达）
   - 交
     - $R\bigcap S = \{t|t\in R and t\in S\}$
     - 交运算的关系是相容的
   - 自然连接
     - ⋈
     - 要求进行笛卡尔积的两个属性在相同属性上的取值一致。
     - 去除重复属性
   - $\theta$-连接
     - 原子公式构成的公式
   - 赋值 $\leftarrow$
     - 右侧结果赋给左侧关系变量（临时关系变量）
     - 就查询而言，幅值必须赋给一个临时关系变量
   - 除
     - 设，R和S是两个关系，X = U(R),Y = U(S),Z = X-Y,$R\div S = \{t | t\in\Pi_Z(R) \land \forall u\in S(tu\in R)\}$
   - 外连接
     - 用于处理缺失值
     - 左外连接：取出左侧关系中所有与右侧关系任意元组都不匹配的元组，<mark>用空值填充所有来自右侧wei关系的属性。</mark>
     - 右外连接
     - 全外连接：左右外连接的并

  扩展的关系代数运算：（实现不能用基本代数运算来表达的查询）
   - 广义投影：
     - 允许投影列表中使用算术运算和字符
   - 聚集：

### 2.3.2 元组演算（非过程性的）
  元组关系演算：（非过程化的查询）只需描述所需信息，而不给出获得该信息的具体过程。
   - 表达式$\{t|P(t)\}$
     - 是所有使得公式P为真的元组t的集合
     - t[A]表示元组t在A属性上的取值
   - 元组关系演算的公式P由原子公式构成
     - 原子公式的形式：
       - 属于，两个元组变量比较，元组变量与常量比较
  
### 2.3.3 域演算
  与演算表达式：
   - 与元祖演算联系紧密，使用从属性域中取值的域变量，而不是整个元组的值
   - 形式化定义：$\{<x_1,x_2,...,x_n>|P(x_1,x_2,...,x_n\}$
     - $x_1,x_2,..,x_n$分别是域变量
     - P由原子公式构成
     - 查询结果是所有包含$x_1,x_2,..,x_n$的元组，并且$x_1,x_2,..,x_n$使得$P(x_1,x_2,...,x_n$为真。
   - 原子公式的形式：
     - 属于，两个域变量比较，域变量与常量比较
  
  关系运算的安全性：如果一个关系运算系统不产生无限关系和无穷验证，则这个运算是安全的。
   - 关系代数系统安全
   - 元组关系演算和域关系演算系统不安全。引入元组关系公式的域的概念，对关系演算进行限制。

  下述三者是等价的：
   - 基本关系代数
   - 限制在安全表达式范围内的元组关系预算
   - 限制在安全表达式范围内的域关系演算
 
  上述三者可以扩展以支持聚集运算，但不等价。
# 第三章 结构化查询语言SQL
## 概览
  SQL语言有以下部分：
   - 数据定义语言：提供定义关系模式、删除关系以及修改关系模式的命令。
   - 数据操作语言：提供从数据中查询信息、以及在数据中心插入元组、删除元组、修改元组的能力
   - 完整性
   - 视图定义
   - 事务控制：定义事务的开始和结束
   - 嵌入式SQL和动态SQL
   - 授权

  SQL语言的特点：
   - 综合统一
   - 高度非过程化
   - 面向集合的操作方式
   - 预言简洁、易学易用
  
## 3.2 SQL语言数据定义机制
  数据定义语句（DDL）包含以下语句：

  |      |  创建        | 删除      | 修改        |
  | -----| ------------ | --------- | ---------- |
  | 表   | CREATE TABLE |DROP TABLE |ALTER TABLE |
  | 视图 | CREATE VIEW  |DROP VIEW  |            |
  | 索引 | CREATE INDEX |DROP INDEX |            |
  ***
  建立关系模式

  ~~~
  CREATE TABLE <>
    (<属性名><属性类型>[NOT NULL],...,
     <属性名><属性类型>[NOT NULL],...,
      完整性约束1，完整性约束2,...);
  ~~~

  属性类型:
   - char(n),varchar(n)
   - int,smallint
   - numeric(p,d)
   - real,float(n),double precision...
  
  完整性约束:
   - primary key($A_1,A_2,...,A_n$)：声明属性$(A_1,A_2,...,A_n)$构成关系的主码，必须非空且唯一
   - foreign key$(A_1,A_2,...,A_n)$ reference s：声明表示关系中任意元组在属性$(A_1,A_2,...,A_n)$的取值必须对应于关系s中某元组在主属性上的取值
   - not null：不允许空值
  
  ***
  修改关系模式

  ~~~
  ALTER TABLE <关系命> ADD|DROP <列名> <列类型>
  ~~~

  ***
  修改关系模式

  ~~~
  DROP TABLE <关系名>
  ~~~

  不仅删除关系的所有元组，还删除关系模式

  ***
  建立索引

  ~~~
  CREATE [UNIQUE] INDEX <索引名> ON <关系> (<列名> [ORDER],...,<列名> [ORDER])[CLUSTER]
  ~~~

  <mark>UNIQUE表示所以属性或属性组是主码属性，即不允许重复值</mark>

  功能：
   - 在一个指定关系的指定属性上建立索引
   - ORDER：ASC 或 DESC
   - CLUSTER：是否为聚集索引

  ***
  删除索引

  ~~~
  DROP INDEX <索引名>
  ~~~

  ***
  定义视图

  视图：隐藏特定的数据，符合用户直觉，是从一个或几个基本表（或视图）导出的虚关系。本身不保存数据，数据仍保存在基本表中。

  ~~~
  CREATE VIEW <视图名>
                 [(<列名>[,<列名>]...)]
        AS <子查询>
        [WITH CHECK OPTION];
  ~~~

  说明：
   - 组成视图的属性列名或全部省略或全部制定
   - 子查询：合法的查询表达式
   - WITH CHECK OPTION：透过视图进行删改操作时，不得破坏视图定义中的谓词条件（即子查询中的条件表达式）

  <mark>只是把视图的定义存入数据字典，并不执行其中的SELECT语句。只是再对视图查询时，才按师徒的定义从基本表中将数据查出。</mark>

  ***
  删除视图

  ~~~
  DROP VIEW <视图名> [CASCADE]
  ~~~

  如果没有指定CASCADE选项，而该视图定义了其他视图，则该语句将被拒绝执行。如果指定，则该视图和由他导出的所有视图一起删除。
## 3.3 SQL查询
  一般语法格式：
  ~~~
  SELECT [DISTINCT/ALL] <列表达式> [列名][,<列表达式> [列名]]...
  FROM <表名> [<别名>] [,<表名> [<别名>]]...
  [WHERE <条件表达式>（元组需要满足条件）]
  [GROUP BY <分组属性表> [HAVING <条件表达式>（分组需要满足条件）]]
  [ORDER BY <列名> [OIRDER],...,<列名>[ORDER]];
  ~~~

  单表查询：查询仅设计一个表
   - 选择表中的若干列
     - 查询指定列时，在SELECT子句的<列表达式>中指定要查询的属性，其中的顺序可以与表中的逻辑顺序不一致
   - 查询全部列：列出所有列名或列表达式为*
   - 查询经过计算的值
     - SELECT子句中的<列表达式>为计算表达式
   - 使用列别名改变查询结果的列标题：<列名> as <列别名>
   - 选择表中若干元组
     - 查询满足条件的元组，通过WHERE子句实现
     - 清除取值重复的行   DISTINCT
     - 明确要求不清楚重复的行   ALL
     - 常用查询条件：比较、确定范围（BETWEEN AND）、确定集合（IN）空值、多重条件（AND，OR）、字符串运算（upper(),lower(),like,escape）（通配符%替代0个或多个字符，_仅替代一个字符）
     - ESCAPE短语：当用户查询的字符串本身就含有%或者_（通配符）时，要使用ESCAPE'<换码字符>'短语对通配符进行转义
   - 对查询结果排序：使用ORDER子句，可以按一个活多个属性排序，ASC DESC，缺省值为升序。
   - 聚集函数：
     - COUNT([DISTINCT | ALL] *)统计元祖个数。<mark>计算由查询中from和where子句创建的关系中的元组个数</mark>
     - COUNT([DISTINCT | ALL] <列名>)统计一列中值得个数。<mark>计算某一列中值得个数，控制不计入</mark>
     - SUM([DISTINCT | ALL] <列名>)计算一列的总和
     - AVG([DISTINCT | ALL] <列名>)计算一列的平均值
     - MAX([DISTINCT | ALL] <列名>)计算一列的最大值
     - MIN([DISTINCT | ALL] <列名>)计算一列的最小值
   - GROUP BY用途：细化聚集函数的作用对象
     - 未分组时，聚集函数作用于整个查询结果；分组后，分别作用于每个组。
     - 任何没有出现在group by子句中的属性如果出现在select子句中，他只能出现在聚集函数内部。
  
  连接查询：同时涉及多个表的查询。
   - 连接条件：用来连接两个表的条件称为连接条件或链接谓词。<mark>连接条件中各连接属性类型必须是可比的。</mark>
   - 常用格式：[<表名1>.] <列名1> <比较运算符> [<表名2>.] <列名2>
  
  嵌套子查询：
   - 一个SELECT-FROM-WHERE语句称为一个查询块
   - 不能使用ORDER BY子句
   - 将一个查询块嵌套到另一个查询块的WHERE、FROM、HAVING短语的条件中的查询叫做嵌套子查询
   - 求解方法：由内到外
   - 限制：不能使用ORDER BY子句。有些嵌套查询可以用连接运算代替。
   - 子查询的查询条件依赖于外层父查询的某个属性值，则称为相关子查询。
   - 可以在查询块外使用存在量词。若内层查询结果非空，则外层的where子句返回真值，否则返回假植。

  集合查询：
   - 并UNION，交INTERSECT，差EXCEPT
   - 各结果表列数必须相同，对应数据类型也必须相同（相容的）。自动去掉重复行

## 3.4 SQL数据库的修改
  更新机制：插入、删除、修改

  DBMS在执行插入修改及删除语句时会检查是否破坏表上已定义的完整性规则（实体完整性、参照完整性、用户定义的完整性等）。

  ***
  插入数据

  插入单个数据：
  ~~~
  INSERT
  INTO <表名> [(<属性列1>) [,<属性列2>...]]
  VALUES(<常量1> [, <常量2>]...);
  ~~~
  
  插入子查询结果：
  ~~~
  INSERT
  INTO <表名> [(<属性列1>) [,<属性列2>...]]
  子查询;
  ~~~

  ***
  修改数据
  ~~~
  UPDATE <表名>
  SET <列名> = <表达式>[, <列名> = <表达式>]...
  [WHERE <条件>];
  ~~~

  修改指定表中满足where子句的元组，set指定要修改的列和修改后的值

  ***
  修改数据
  ~~~
  DELETE
  FROM <表名>
  [WHERE <条件>]
  ~~~

## 3.5 SQL事务
  事务由查询和（或）更新语句的序列组成
   - commit：提交当前事务，将该事务所做的更新在数据库中持久更新。
   - rollback：回滚当前事务，撤销更新。恢复到执行该事务第一条语句之前的状态
   - 一个事务或者在完成所有步骤后提交其行为，合作和在不能成功完成其所有动作的情况下回滚其所有动作。
     - 事务的原子性
     - 事务的定义：begin atomic... end
  
## 3.6 SQL触发器
  触发器是一条语句，当对数据进行修改时它自动被执行。

  设置触发器机制，必须满足两个要求：1、指明什么条件下触发 2、指明触发器的动作

  触发器输入到数据库中后，只要指定的时间发生，相应的条件满足，数据库就有责任执行。

## 3.7 SQL数据库授权机制
  授权：
   - 语法格式
  ~~~
  GRANT <privilege list> ON <object> TO <user ID list>
  [WITH GRANT OPTION]
  ~~~
   - 权限列表(privilege list)
     - 读取数据(select)
     - 插入新数据(insert)
     - 更新数据(update)
     - 删除数据(delete)
   - 最大的授权形式是被授予数据库管理员，其可以授予新用户、重构数据库
  
  权限回收：
   - 语法格式：
  ~~~
  REVOKE <privilege list> ON <object> FROM <user ID list>
  [Restrict/Cascade]
  ~~~
   - restrict：防止级联回收
   - cascade：支持级联回收（默认）
  
# 第四章 概念数据库设计
  数据库设计步骤

  需求分析：
   - 重点是
     - 数据和处理
     - 信息要求
     - 处理要求
     - 安全性与完整性要求
   - 步骤
     - 应用领域的调查分析
     - 定义数据库支持的信息与应用
     - 定义数据库操作任务
     - 预测应用领域的未来改变
  
## 4.2 概念数据库设计
  目标：准确描述应用领域的信息模式，支持用户的各种应用（不失真），既易于转换为逻辑数据库模式，又容易被用户理解（易理解）。

  概念数据库模式独立于任何数据库关系李彤，不能直接用于数据库的实现。

  实体联系模型（ER模型）：被表示成实体-联系图，图中有三个主要元素：实体、属性和联系

  实体：每个实体都有一组特征或者性质，称为实体的属性。实体的属性的一组特定值确定一个特定的实体。实体的属性值是数据库中存储的主要数据。

  实体集：

  实体属性：
   - 多数实体属性都是单值属性，即同一属性只能取一个值
   - 在某些情况下，一些属性可能取多个值，这样的属性称为多值属性
   - 可以划分为多个具有独立意义的子属性，称为复合属性，具有层次结构
   - 空值
  
  实体属性（码）
   - ER模型中每个实体集具有一个由一个或多个属性组成的码，是足以区分每个实体的属性值
   - 有一个属性组成的键称为简单码。由多个属性构成的键称为复合码，统称为码。

  联系：不同实体集之间可能具有某种关联，我们称这种关联为实体之间的联系。

  联系集：同类联系的集合
   - 联系集的阶
   - 描述性属性

  实体之间的联系既可以使用联系集定义，也可以通过实体属性来表示

  约束：
   - 可以定义一写数据必须满足的约束
   - 映射基数：一个实体通过一个联系集能关联的实体的个数
   - 参与约束
     - 全域关联约束（部分关联约束）：在ER模型中，在联系集中参与是全部的，则是全域关联的。
     - 联系集上的基数限制：限制每个实体参与联系集的联系的次数。
       - l..h，其中l表示最小基数，h表示最大基数。
       - l=1表示实体参与全部联系集，h=*表示没有限制。
  
  弱实体集：必须具有一个或多个属性
   - 没有足够的恶属性以形成主码的实体集称为弱实体集
   - 必须与另一个称作标识或属主实体集的实体集关联才有意义，该关联集称作标志性联系
   - 标识性联系从弱实体集到标识实体集是多对一的
   - 使用分辨符区分依赖于特定强实体集的弱实体集中的实体，分辨符也称为实体集的部分码。其主码由实体集的主码加分辨符组成。
   - ![](markdown_img/2022-04-12-01-23-59.png

  实体联系图：是表示ER模型的图形工具，用来表示实体和实体联系集。

  联系集外至多只能有一个箭头，因为会有两种解释方法。（函数依赖解释）
  
## 4.3 概念数据库设计的方法与策略
  集中式设计方法：
   - 合并在需求阶段得到的各种应用需求
  
  视图综合设计法：
   - 不要求应用需求合并
   - 视图设计阶段：根据每个应用的需求设计一个视图。
   - 视图合并阶段：把所有视图有机合并成一个统一的概念数据库模式，支持所有应用

  自底向上的策略：

  视图综合设计方法：
   - 第一步设计局部概念模式
   - 第二部吧局部概念模式合并为一个

  局部概念模式设计：
   - 抽取个局部应用设计的数据，标定各局部应用中的实体、实体的属性、表示实体的码、确定实体之间的联系机器约束
   - 形成局部E-R图

  冲突的种类：
   - 命名冲突
   - 模式结构冲突：相同概念在不同局部模式中使用不同的概念模式表示。
   - 值域冲突
   - 约束冲突

  全局模式合成方法：
   - 二元阶梯合成法
   - N元合成法
   - 平衡二合成法
   - 混合合成法

## 4.4 事务设计
  事务设计任务：定义事务功能
   - 说明事务的输入输出

# 第五章 逻辑数据库设计
  逻辑数据库设计的任务：把概念数据库设计阶段产生的概念数据库模式变换为逻辑数据库模式

  逻辑数据库设计的目标：
   - 满足用户的完整性和安全性要求
   - 动态关系至少具有第三规范形式，静态关系至少具有第一规范形式。

  逻辑数据库设计的步骤：
   - 形成初始关系数据库模式
   - 关系模式规范化
   - 关系模式优化
   - 定义关系上的完整性和安全性约束
   - 子模式定义
   - 性能评估
## 5.1 形成初始关系数据库模式
  普通实体集的变换

  弱实体变换

  多值数型的变换
   - 设实体集E具有多值属性，S是E对应的关系

  实体间联系的变换





  依赖

  蕴含

  Armstrong 公理系统：
   - 包含三条推理规则：
     - 自反律
     - 增广律
     - 传递律
  
  导出规则：
   - 得出三条推理规则：
     - 合并规则
     - 伪传递规则
     - 分解规则
   - 根据合并规则和分解规则，有引理：
  
  闭包：

  计算闭包

  快速求解候选码的方法：L和N类一定包含，LR类可能包含，R类肯定不包含。

  极小函数依赖（不唯一）

  计算极小函数依赖集

  关系模式的规范模式